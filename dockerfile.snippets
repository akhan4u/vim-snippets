snippet python_dockerfile "Dockerfile for Python Application" !b
FROM python:3.6-alpine
COPY . /app
WORKDIR /app
RUN apk add --update alpine-sdk mariadb-dev && cp /app/mysql_config /usr/local/bin && pip install --no-cache-dir -r requirements.txt
ENTRYPOINT ["/usr/local/bin/python"]
CMD ["app.py"]
endsnippet

snippet flask_dockerfile "Dockerfile for Python Flask application" !b
FROM python:3.8-slim-buster

WORKDIR /app

COPY requirements.txt requirements.txt
RUN pip3 install --no-cache-dir -r requirements.txt

COPY . .

CMD [ "python3", "-m" , "flask", "run", "--host=0.0.0.0"]
endsnippet

snippet nodejs_dockerfile "Dockerfile for Nodejs Application" !b
FROM node:10-alpine
WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN apk update \
        && apk upgrade \
        && apk --no-cache add --virtual builds-deps build-base python \
        && npm install --only=production --build-from-source \
        && apk del builds-deps build-base python \
        && rm -rf /var/cache/apk/*
COPY . .
EXPOSE 8080
CMD [ "npm", "run-script", "serve" ]
HEALTHCHECK CMD curl --fail http://localhost:8080/ || exit 1
endsnippet

snippet nodejs_dockerfile2 "Dockerfile2 for Nodejs Application" !b
FROM node:alpine
WORKDIR /usr/src/app
COPY package.json /usr/src/app/
RUN npm install
COPY . .
CMD ["npm", "run", "start"]
endsnippet

snippet angular_dockerfile "Dockerfile for Angular Application" !b
# Stage 1
FROM node:10-alpine as build-step
RUN mkdir -p /app
WORKDIR /app
COPY package.json /app
RUN npm install
COPY . /app
RUN npm run build --prod

# Stage 2
FROM nginx:1.17.1-alpine
COPY --from=build-step /app/docs /usr/share/nginx/html
endsnippet

snippet java_dockerfile "Dockerfile for Java Application" !b
## Spring-Boot Docker Image.
## Minimal Base Images, Use Fixed Tags For Immutability
## Alpine Is A Docker Official Imagejava
FROM alpine:3.11.3
USER root
RUN apk add --no-cache openjdk11 --repository=http://dl-cdn.alpinelinux.org/alpine/edge/community

## Create appuser, A Least Privileged User
RUN addgroup -g 1000 -S appuser && \
        adduser -u 1000 -S appuser -G appuser
WORKDIR /home/appuser/app

## Switch User To appuser
USER appuser

EXPOSE 8991
COPY service/target/*exec.jar app.jar
ENTRYPOINT ["java", "-jar", "./app.jar"]
endsnippet

snippet gradle_dockerfile "Dockerfile for Java Gradle Application" !b
# Build in Gradle Container as Builder
FROM gradle:4.7.0-jdk8-alpine AS build
COPY --chown=gradle:gradle . /home/gradle/src
WORKDIR /home/gradle/src
RUN gradle build --no-daemon

# Use Centos Base Image
FROM centos:7
RUN yum install java-1.8.0-openjdk -y && yum clean all

## Create appuser, A Least Privileged User
RUN groupadd -g 1000 appuser && \
        useradd -u 1000 -g appuser -s /bin/sh appuser
WORKDIR /home/appuser/app

## Switch User To appuser
USER appuser

# Expose Port 8080 For App
EXPOSE 8080

# Copy Java Artifact from Build
COPY --from=build /home/gradle/src/build/libs/*.jar spring-boot-application.jar

ENTRYPOINT ["java", "-XX:+UnlockExperimentalVMOptions", "-XX:+UseCGroupMemoryLimitForHeap", "-Djava.security.egd=file:/dev/./urandom","-jar","spring-boot-application.jar"]
endsnippet

snippet buildkit_dockerfile "Buildkit for managing secrets during docker build" !b
# syntax=docker/dockerfile:1.2
FROM ubuntu


RUN apt-get update && \
        apt-get upgrade && \
            apt-get install -y curl --no-install-recommends


# Mounting a Secret, '/tmp/secret' is the file present on 'docker build' host machine with following content
# ‚ùØ cat /tmp/secret
# admin:admin
RUN --mount=type=secret,id=mysecret,dst=/tmp/secret cat /tmp/secret

# Using the secret in underlying RUN command
RUN --mount=type=secret,id=mysecret,dst=/tmp/secret curl -o /tmp/getsecret.txt -u $(cat /tmp/secret) http://192.168.56.1:9090/secret.txt


# This above Dockerfile can be built, using below command:
# DOCKER_BUILDKIT=1 docker build --no-cache --progress=plain -t secret:buildkit --secret id=mysecret,src=/tmp/secret .
endsnippet
